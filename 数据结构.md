## 线性表

```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 50
typedef int ElemType;
//静态分配
typedef struct{
	ElemType data[MaxSize];
	int length;//当前顺序表中有多少个元素
}SqList;
//动态分配
#define InitSize 100
typedef struct{
	ElemType *data;
	int capacity;//动态数组的最大容量
	int length;
}SeqList;
//i代表插入的位置，从1开始，e要插入的元素
bool ListInsert(SqList &L,int i,ElemType e)
{
	if(i<1||i>L.length+1)//判断要插入的位置是否合法
		return false;
	if(L.length>=MaxSize)//超出空间了
		return false;
	for(int j=L.length;j>=i;j--)//移动顺序表中的元素
		L.data[j]=L.data[j-1];
	L.data[i-1]=e;//数组下标从零开始，插入第一个位置，访问的下标为0
	L.length++;
	return true;
}
//删除使用元素e的引用的目的是拿出对应的值
bool ListDelete(SqList &L,int i,ElemType &e)
{
	if(i<1||i>L.length)//如果删除的位置是不合法
		return false;
	e=L.data[i-1];//获取顺序表中对应的元素，赋值给e
	for(int j=i;j<L.length;j++)
		L.data[j-1]=L.data[j];
	L.length--;//删除一个元素，顺序表长度减1
	return true;
}
//查找成功，返回位置，位置从1开始，查找失败，返回0
int LocateElem(SqList L,ElemType e)
{
	int i;
	for(i=0;i<L.length;i++)
		if(L.data[i]==e)
			return i+1;//加1就是元素在顺序表中的位置
	return 0;
}
//打印顺序表元素
void PrintList(SqList &L)
{
	for(int i=0;i<L.length;i++)
	{
		printf("%4d",L.data[i]);
	}
	printf("\n");
}
int main()
{
	SqList L;//顺序表的名称
	bool ret;//查看返回值，布尔型是True,或者False
	ElemType del;//要删除的元素
	//首先手动在顺序表中赋值
	L.data[0]=1;
	L.data[1]=2;
	L.data[2]=3;
	L.length=3;//总计三个元素
	ret=ListInsert(L,2,60);
	if(ret)
	{
		printf("插入成功\n");
		PrintList(L);
	}else{
		printf("插入失败\n");
	}
	ret=ListDelete(L,1,del);
	if(ret)
	{
		printf("删除成功\n");
		printf("删除元素值为 %d\n",del);
		PrintList(L);
	}else{
		printf("删除失败\n");
	}
	ret=LocateElem(L,60);
	if(ret)
	{
		printf("查找成功\n");
		printf("元素位置为 %d\n",ret);
	}else{
		printf("查找失败\n");
	}
}
```

## 链表

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct LNode{
	ElemType data;
	struct LNode *next;//指向下一个结点 
}LNode,*LinkList;
//头插法新建链表
LinkList CreatList1(LinkList &L)//list_head_insert
{
	LNode *s;int x;
	L=(LinkList)malloc(sizeof(LNode));//带头结点的链表
	L->next=NULL;//L->data里边没放东西
	scanf("%d",&x);//从标准输入读取数据
	//3 4 5 6 7 9999
	while(x!=9999){
		s=(LNode*)malloc(sizeof(LNode));//申请一个新空间给s，强制类型转换
		s->data=x;//把读取到的值，给新空间中的data成员
		s->next=L->next;//让新结点的next指针指向链表的第一个元素（第一个放我们数据的元素）
		L->next=s;//让s作为第一个元素
		scanf("%d",&x);//读取标准输入
	}
	return L;
}
//尾插法新建链表
LinkList CreatList2(LinkList &L)//list_tail_insert
{
	int x;
	L=(LinkList)malloc(sizeof(LNode));//带头节点的链表
	LNode* s, * r = L;//LinkList s,r=L;也可以，r代表链表表尾结点，指向链表尾部
	//3 4 5 6 7 9999
	scanf("%d",&x);
	while(x!=9999){
		s=(LNode*)malloc(sizeof(LNode));
		s->data=x;
		r->next=s;//让尾部结点指向新结点
		r=s;//r指向新的表尾结点
		scanf("%d",&x);
	}
	r->next=NULL;//尾结点的next指针赋值为NULL
	return L;
}
//按序号查找结点值
LNode *GetElem(LinkList L,int i)
{
	int j=1;
	LNode *p=L->next;
	if(i==0)
		return L;
	if(i<1)
		return NULL;
	while(p&&j<i)
	{
		p=p->next;
		j++;
	}
	return p;
}
//按值查找
LNode *LocateElem(LinkList L,ElemType e)
{
	LNode *p=L->next;
	while(p!=NULL&&p->data!=e)
		p=p->next;
	return p;
}
//新结点插入第i个位置
bool ListFrontInsert(LinkList L,int i,ElemType e)
{
	LinkList p=GetElem(L,i-1);
	if(NULL==p)
	{
		return false;
	}
	LinkList s=(LNode*)malloc(sizeof(LNode));//为新插入的结点申请空间
	s->data=e;
	s->next=p->next;
	p->next=s;
	return true;
}
//删除第i个结点
bool ListDelete(LinkList L,int i)
{
	LinkList p=GetElem(L,i-1);
	if(NULL==p)
	{
		return false;
	}
	LinkList q;
	q=p->next;
	p->next=q->next;//断链
	free(q);//释放对应结点的空间
	return true;
}
//打印链表中每个结点的值
void PrintList(LinkList L)
{
	L=L->next;
	while(L!=NULL)//NULL是为了代表一张空的藏宝图
	{
		printf("%3d",L->data);//打印当前结点数据
		L=L->next;//指向下一个结点
	}
	printf("\n");
}
//《王道C督学营》课程
//2.3 线性表的链式表示
int main()
{
	LinkList L;//链表头，是结构体指针类型
	LinkList search;//用来存储拿到的某一个节点
	//CreatList1(L);//输入数据可以为3 4 5 6 7 9999,头插法新建链表
	CreatList2(L);//输入数据可以为3 4 5 6 7 9999
	PrintList(L);//链表打印
	search=GetElem(L,2);
	if(search!=NULL)
	{
		printf("按序号查找成功\n");
		printf("%d\n",search->data);
	}
	search=LocateElem(L,6);//按值查询
	if(search!=NULL)
	{
		printf("按值查找成功\n");
		printf("%d\n",search->data);
	}
	ListFrontInsert(L,2,99);//新结点插入第i个位置
	PrintList(L);
	ListDelete(L,4);//删除第4个结点
	PrintList(L);
    return 0；
}
```

## 双向链表

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct DNode{
	ElemType data;
	struct DNode *prior,*next;//前驱，后继
}DNode,*DLinkList;
//双向链表头插法
DLinkList Dlist_head_insert(DLinkList &DL)
{
	DNode *s;int x;
	DL=(DLinkList)malloc(sizeof(DNode));//带头结点的链表,不带头结点
	DL->next=NULL;
	DL->prior=NULL;
	scanf("%d",&x);//从标准输入读取数据
	//3 4 5 6 7 9999
	while(x!=9999){
		s=(DLinkList)malloc(sizeof(DNode));//申请一个空间空间，强制类型转换
		s->data=x;
		s->next=DL->next;
		if(DL->next!=NULL)//插入第一个结点时，不需要这一步操作
		{
			DL->next->prior=s;
		}
		s->prior=DL;
		DL->next=s;
		scanf("%d",&x);//读取标准输入
	}
	return DL;
}
//双向链表尾插法
DLinkList Dlist_tail_insert(DLinkList &DL)
{
	int x;
	DL=(DLinkList)malloc(sizeof(DNode));//带头节点的链表
	DNode *s,*r=DL;
	DL->prior=NULL;
	//3 4 5 6 7 9999
	scanf("%d",&x);
	while(x!=9999){
		s=(DNode*)malloc(sizeof(DNode));
		s->data=x;
		r->next=s;
		s->prior=r;
		r=s;//r指向新的表尾结点
		scanf("%d",&x);
	}
	r->next=NULL;//尾结点的next指针赋值为NULL
	return DL;
}
//按序号查找结点值
DNode *GetElem(DLinkList DL,int i)
{
	int j=1;
	DNode *p=DL->next;
	if(i==0)
		return DL;
	if(i<1)
		return NULL;
	while(p&&j<i)
	{
		p=p->next;
		j++;
	}
	return p;
}
//新结点插入第i个位置
bool DListFrontInsert(DLinkList DL,int i,ElemType e)
{
	DLinkList p=GetElem(DL,i-1);
	if(NULL==p)
	{
		return false;
	}
	DLinkList s=(DLinkList)malloc(sizeof(DNode));//为新插入的结点申请空间
	s->data=e;
	s->next=p->next;
	p->next->prior=s;
	s->prior=p;
	p->next=s;
	return true;
}
//删除第i个结点
bool DListDelete(DLinkList DL,int i)
{
	DLinkList p=GetElem(DL,i-1);
	if(NULL==p)
	{
		return false;
	}
	DLinkList q;
	q=p->next;
	if(q==NULL)//删除的元素不存在
		return false;
	p->next=q->next;//断链
	if(q->next!=NULL)
	{
		q->next->prior=p;
	}
	free(q);//释放对应结点的空间
	return true;
}
//链表打印
void PrintDList(DLinkList DL)
{
	DL=DL->next;
	while(DL!=NULL)
	{
		printf("%3d",DL->data);
		DL=DL->next;
	}
	printf("\n");
}

//《龙哥带你撸代码》课程
//2.3.3 双链表增删查
int main()
{
	DLinkList DL;
	DLinkList search;
	Dlist_head_insert(DL);
	//Dlist_tail_insert(DL);
	//3 4 5 6 7 9999
	PrintDList(DL);
	search=GetElem(DL,2);
	if(search!=NULL)
	{
		printf("按序号查找成功\n");
		printf("%d\n",search->data);
	}
	DListFrontInsert(DL,3,99);
	PrintDList(DL);
	DListDelete(DL,2);
	PrintDList(DL);
	system("pause");
}
```

## 栈

```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 50
typedef int ElemType;
typedef struct{
	ElemType data[MaxSize];//数组
	int top;
}SqStack;
void InitStack(SqStack &S)
{
	S.top=-1;//代表栈为空
}

bool StackEmpty(SqStack &S)
{
	if(S.top==-1)
		return true;
	else
		return false;
}
//入栈
bool Push(SqStack &S,ElemType x)
{
	if(S.top==MaxSize-1)//数组的大小不能改变，避免访问越界
	{
		return false;
	}
	S.data[++S.top]=x;
	return true;
}
//出栈
bool Pop(SqStack &S,ElemType &x)
{
	if(-1==S.top)
		return false;
	x=S.data[S.top--];//后减减，x=S.data[S.top];S.top=S.top-1;
	return true;
}
//读取栈顶元素
bool GetTop(SqStack &S,ElemType &x)
{
	if(-1==S.top)//说明栈为空
		return false;
	x=S.data[S.top];
	return true;
}
//《王道C督学营》课程
//王道数据结构 3.1 栈
//实现栈 可以用数组，也可以用链表，我们这里使用数组
int main()
{
	SqStack S;//先进后出 FILO  LIFO
	bool flag;
	ElemType m;//用来存放拿出的元素
	InitStack(S);//初始化
	flag=StackEmpty(S);
	if(flag)
	{
		printf("栈是空的\n");
	}
	//Push(S,3);//入栈元素3
	//Push(S,4);//入栈元素4
	//Push(S,5);
    int i, num;
	for (i = 0; i < 3; i++)
	{
		scanf("%d", &num);
		Push(S, num);
	}
	for (i = 0; i < 3; i++)
	{
		Pop(S, m);
		printf("%2d", m);
	}
	printf("\n");
    
	flag=GetTop(S,m);//获取栈顶元素
	if(flag)
	{
		printf("获取栈顶元素为 %d\n",m);
	}
	flag=Pop(S,m);//弹出栈顶元素
	if(flag)
	{
		printf("弹出元素为 %d\n",m);
	}
	system("pause");
}
```

## 循环队列

```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 5
typedef int ElemType;
typedef struct{
	ElemType data[MaxSize];//数组,存储MaxSize-1个元素
	int front,rear;//队列头 队列尾
}SqQueue;

void InitQueue(SqQueue &Q)
{
	Q.rear=Q.front=0;
}
//判空
bool isEmpty(SqQueue &Q)
{
	if(Q.rear==Q.front)//不需要为零
		return true;
	else
		return false;
}
//入队
bool EnQueue(SqQueue &Q,ElemType x)
{
	if((Q.rear+1)%MaxSize==Q.front) //判断是否队满
		return false;
	Q.data[Q.rear]=x;//3 4 5 6
	Q.rear=(Q.rear+1)%MaxSize;
	return true;
}
//出队
bool DeQueue(SqQueue &Q,ElemType &x)
{
	if(Q.rear==Q.front)
		return false;
	x=Q.data[Q.front];//先进先出
	Q.front=(Q.front+1)%MaxSize;
	return true;
}
//《王道C督学营》课程
//王道数据结构 3.2 循环队列
int main()
{
	SqQueue Q;
	bool ret;//存储返回值
	ElemType element;//存储出队元素
	InitQueue(Q);
	ret=isEmpty(Q);
	if(ret)
	{
		printf("队列为空\n");
	}else{
		printf("队列不为空\n");
	}
    
    for (i = 0; i < 5; i++)//入队5个元素，最后一个元素不会入队成功
	{
		scanf("%d", &num);
		flag=EnQueue(Q, num);
		if (false == flag)
		{
			printf("false\n");
		}
	}
	ElemType element;
	for (i = 0; i < 4; i++)//出队4个元素并打印每一个
	{
		DeQueue(Q, element);
		printf("%2d", element);
	}
	printf("\n");
    
	EnQueue(Q,3);
	EnQueue(Q,4);
	EnQueue(Q,5);
	ret=EnQueue(Q,6);
	ret=EnQueue(Q,7);
	if(ret)
	{
		printf("入队成功\n");
	}else{
		printf("入队失败\n");
	}
	ret=DeQueue(Q,element);
	if(ret)
	{
		printf("出队成功,元素值为 %d\n",element);
	}else{
		printf("出队失败\n");
	}
	ret=DeQueue(Q,element);
	if(ret)
	{
		printf("出队成功,元素值为 %d\n",element);
	}else{
		printf("出队失败\n");
	}
	ret=EnQueue(Q,8);
	if(ret)
	{
		printf("入队成功\n");
	}else{
		printf("入队失败\n");
	}
	system("pause");
}
```

## 队列的链式存储

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	LinkNode *front,*rear;//链表头 链表尾
}LinkQueue;//先进先出

void InitQueue(LinkQueue &Q)
{
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//头和尾指向同一个结点
	Q.front->next=NULL;
}

bool IsEmpty(LinkQueue Q)
{
	if(Q.front==Q.rear)
		return true;
	else
		return false;
}
//入队，尾部插入法
void EnQueue(LinkQueue &Q,ElemType x)
{
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;s->next=NULL;
	Q.rear->next=s;//rear始终指向尾部
	Q.rear=s;
}
//出队  头部删除法
bool DeQueue(LinkQueue &Q,ElemType &x)
{
	if(Q.front==Q.rear) return false;//队列为空
	LinkNode *p=Q.front->next;//头结点什么都没存，所以头结点的下一个节点才有数据
	x=p->data;
	Q.front->next=p->next;//断链
	if(Q.rear==p)//删除的是最后一个元素
		Q.rear=Q.front;//队列置为空
	free(p);
	return true;
}
//《王道C督学营》课程
//王道考研数据结构 3.2.3 队列的链式存储
//头部删除法，尾部插入法
int main()
{
	LinkQueue Q;
	bool ret;
	ElemType element;//存储出队元素
	InitQueue(Q);
	EnQueue(Q,3);
	EnQueue(Q,4);
	EnQueue(Q,5);
	EnQueue(Q,6);
	EnQueue(Q,7);
	ret=DeQueue(Q,element);
	if(ret)
	{
		printf("出队成功,元素值为 %d\n",element);
	}else{
		printf("出队失败\n");
	}
	system("pause");
}

```

## 二叉树

### 二叉树的遍历

function.h

```c++
#include <stdio.h>
#include <stdlib.h>
//作者 王道训练营 龙哥
typedef char BiElemType;
typedef struct BiTNode{
	BiElemType c;//c就是书籍上的data
	struct BiTNode *lchild;
	struct BiTNode *rchild;
}BiTNode,*BiTree;

typedef struct tag{
	BiTree p;//树的某一个结点的地址值
	struct tag *pnext;
}tag_t,*ptag_t;

//栈的相关数据结构
#define MaxSize 50
typedef BiTree ElemType;
typedef struct{
	ElemType data[MaxSize];
	int top;
}SqStack;
void InitStack(SqStack &S);
bool StackEmpty(SqStack &S);
bool Push(SqStack &S,ElemType x);
bool Pop(SqStack &S,ElemType &x);
bool GetTop(SqStack &S,ElemType &x);
//队列的相关数据结构
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	LinkNode *front,*rear;
}LinkQueue;
void InitQueue(LinkQueue &Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue &Q,ElemType x);
bool DeQueue(LinkQueue &Q,ElemType &x);

```

queue.cpp

```c++
#include "function.h"
//带头结点的队列
void InitQueue(LinkQueue &Q)
{
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next=NULL;
}

bool IsEmpty(LinkQueue Q)
{
	if(Q.front==Q.rear)
		return true;
	else
		return false;
}

void EnQueue(LinkQueue &Q,ElemType x)
{
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;s->next=NULL;
	Q.rear->next=s;
	Q.rear=s;
}

bool DeQueue(LinkQueue &Q,ElemType &x)
{
	if(Q.front==Q.rear) return false;
	LinkNode *p=Q.front->next;//头结点什么都没存，所以头结点的下一个节点才有数据
	x=p->data;
	Q.front->next=p->next;
	if(Q.rear==p)
		Q.rear=Q.front;
	free(p);
	return true;
}
```

stack.cpp

```c++
#include "function.h"


void InitStack(SqStack &S)
{
	S.top=-1;
}

bool StackEmpty(SqStack &S)
{
	if(S.top==-1)
		return true;
	else
		return false;
}
//入栈
bool Push(SqStack &S,ElemType x)
{
	if(S.top==MaxSize-1)
	{
		return false;
	}
	S.data[++S.top]=x;
	return true;
}
//出栈
bool Pop(SqStack &S,ElemType &x)
{
	if(-1==S.top)
		return false;
	x=S.data[S.top--];
	return true;
}
//读取栈顶元素
bool GetTop(SqStack &S,ElemType &x)
{
	if(-1==S.top)
		return false;
	x=S.data[S.top];
	return true;
}
```

main.cpp

```c++
#include "function.h"

//递归实现
//abdhiejcfg  前序遍历，前序遍历就是深度优先遍历
void preOrder(BiTree p)
{
	if(p!=NULL)
	{
		putchar(p->c);//等价于visit函数
		preOrder(p->lchild);
		preOrder(p->rchild);
	}
}
//中序遍历  hdibjeafcg
void InOrder(BiTree p)
{
	if(p!=NULL)
	{
		InOrder(p->lchild);
		putchar(p->c);
		InOrder(p->rchild);
	}
}
//hidjebfgca  后序遍历
void PostOrder(BiTree p)
{
	if(p!=NULL)
	{
		PostOrder(p->lchild);
		PostOrder(p->rchild);
		putchar(p->c);
	}
}
//中序遍历非递归，非递归执行效率更高，考的概率很低
void InOrder2(BiTree T)
{
	SqStack S;
	InitStack(S);BiTree p=T;
	while(p||!StackEmpty(S))//逻辑或||
	{
		if(p)
		{//当一个结点不为空，压栈，并取左孩子
			Push(S,p);
			p=p->lchild;
		}else{//弹出栈中元素并打印，获取打印元素的右结点
			Pop(S,p);putchar(p->c);
			p=p->rchild;
		}
	}
}
//层次遍历,层序遍历，广度优先遍历
void LevelOrder(BiTree T)
{
	LinkQueue Q;//辅助队列
	InitQueue(Q);//初始化队列
	BiTree p;
	EnQueue(Q,T);//树根入队
	while(!IsEmpty(Q))
	{
		DeQueue(Q,p);//出队当前结点并打印
		putchar(p->c);
		if(p->lchild!=NULL) //入队左孩子
			EnQueue(Q,p->lchild);
		if(p->rchild!=NULL)  //入队右孩子
			EnQueue(Q,p->rchild);
	}
}
//《王道C督学营》课程
//二叉树的建树（层次建树），前序、中序、后序遍历、中序非递归遍历、层次遍历
int main()
{
	BiTree pnew;
	int i,j,pos;
	char c;
	BiTree tree=NULL;//树根
	ptag_t phead=NULL,ptail=NULL,listpnew=NULL,pcur=NULL;//phead就是队列头，ptail就是队列尾
	//abcdefghij
	while(scanf("%c",&c)!=EOF)
	{
		if(c=='\n')
		{
			break;
		}
		pnew=(BiTree)calloc(1,sizeof(BiTNode));//calloc申请空间并对空间进行初始化，赋值为0
		pnew->c=c;//数据放进去
		listpnew=(ptag_t)calloc(1,sizeof(tag_t));//给队列结点申请空间
		listpnew->p=pnew;
		if(NULL==tree)
		{
			tree=pnew;//树的根
			phead=listpnew;//队列头
			ptail=listpnew;//队列尾
			pcur=listpnew;
			continue;
		}else{
			ptail->pnext=listpnew;//新结点放入链表，通过尾插法
			ptail=listpnew;//ptail指向队列尾部
		}//pcur始终指向要插入的结点的位置
		if(NULL==pcur->p->lchild)//如何把新结点放入树
		{
			pcur->p->lchild=pnew;//把新结点放到要插入结点的左边
		}else if(NULL==pcur->p->rchild)
		{
			pcur->p->rchild=pnew;//把新结点放到要插入结点的右边
			pcur=pcur->pnext;//左右都放了结点后，pcur指向队列的下一个
		}
	}
	printf("--------前序遍历----------\n");//也叫先序遍历，先打印当前结点，打印左孩子，打印右孩子
	preOrder(tree);
	printf("\n--------中序遍历------------\n");//先打印左孩子，打印父亲，打印右孩子
	InOrder(tree);
	printf("\n--------后序遍历------------\n");//先打印左孩子，打印右孩子，最后打印父亲
	PostOrder(tree);
	printf("\n--------中序遍历非递归------\n");//重要性低
	InOrder2(tree); 
	printf("\n--------层次遍历-----------\n");
	LevelOrder(tree);
	printf("\n");
	system("pause");
} 
```

### 线索二叉树

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//作者 王道训练营 龙哥
typedef char ElemType;
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild,*rchild;
	int ltag,rtag;
}ThreadNode,*ThreadTree;
//手工建线索树，总计5个结点
void BulidThreadTree(ThreadTree &T)
{
	ThreadTree arr[5];
	int i;
	for(i=0;i<5;i++)
	{
		arr[i]=(ThreadTree)malloc(sizeof(ThreadNode));
		memset(arr[i],0,sizeof(ThreadNode));
		arr[i]->data='A'+i;
	}
	arr[0]->lchild=arr[1];
	arr[0]->rchild=arr[2];
	arr[1]->rchild=arr[3];
	arr[2]->lchild=arr[4];
	T=arr[0];
}
//不理解直接放弃
void InThread(ThreadTree &p,ThreadTree &pre)
{
	if(p!=NULL){
		InThread(p->lchild,pre);//递归找树的左孩子
		if(p->lchild==NULL){//左边为NULL,填写当前结点的前驱
			p->lchild=pre;
			p->ltag=1;
		}
		if(pre!=NULL&&pre->rchild==NULL){
			//pre节点右孩子为NULL，就让其指向后继节点，而后继结点刚好就是p
			pre->rchild=p;
			pre->rtag=1;
		}
		pre=p;
		InThread(p->rchild,pre);
	}
}
void CreateInThread(ThreadTree T)
{
	ThreadTree pre=NULL;//使用辅助指针pre
	if(T!=NULL){
		InThread(T,pre);
		pre->rchild=NULL;
		pre->rtag=1;
	}
}
//中序序列下的第一个结点
ThreadNode *Firstnode(ThreadNode *p)
{
	while(p->ltag==0)
		p=p->lchild;
	return p;
}
//p在中序序列下的后继结点
//《王道C督学营》课程，考研没考过大题，主要是实际没应用场景
int main()
{
	ThreadTree T;
	ThreadTree p;
	BulidThreadTree(T);
	CreateInThread(T);//构建线索二叉树
	p=Firstnode(T);
	printf("最左下结点值为 %c\n",p->data);
	system("pause");
}
```

### 二叉排序树

```c++
#include <stdio.h>
#include <stdlib.h>


typedef int KeyType;
typedef struct BSTNode{
	KeyType key;
	struct BSTNode *lchild,*rchild;
}BSTNode,*BiTree;
//54,20,66,40,28,79,58
int BST_Insert(BiTree &T,KeyType k)
{
	if(NULL==T)
	{	//为新节点申请空间，第一个结点作为树根
		T=(BiTree)malloc(sizeof(BSTNode));
		T->key=k;
		T->lchild=T->rchild=NULL;
		return 1;//代表插入成功
	}
	else if(k==T->key)
		return 0;//发现相同元素，就不插入
	else if(k<T->key)//如果要插入的结点，小于当前结点
		return BST_Insert(T->lchild,k);//函数调用结束后，左孩子和原来的父亲会关联起来
	else
		return BST_Insert(T->rchild,k);
}
//创建二叉排序树
void Creat_BST(BiTree &T,KeyType str[],int n)
{
	T=NULL;
	int i=0;
	while(i<n)
	{
		BST_Insert(T,str[i]);//把某一个结点放入二叉查找树
		i++;
	}
}
//递归算法简单，但执行效率较低，递归实现留给大家编写
BSTNode *BST_Search(BiTree T,KeyType key,BiTree &p)
{
	p=NULL;//存储要找的结点的父亲
	while(T!=NULL&&key!=T->key)
	{
		p=T;
		if(key<T->key) T=T->lchild;//比当前节点小，就左边找
		else T=T->rchild;//比当前节点大，右边去
	}
	return T;
}
//这个书上没有二叉排序树删除代码--考大题没那么高
void DeleteNode(BiTree &root,KeyType x){
    if(root == NULL){
        return;
    }
    if(root->key>x){
        DeleteNode(root->lchild,x);
    }else if(root->key<x){
        DeleteNode(root->rchild,x);
    }else{ //查找到了删除节点
        if(root->lchild == NULL){ //左子树为空，右子树直接顶上去
           BiTree tempNode = root;//用临时的存着的目的是一会要free
           root = root->rchild;
           free(tempNode);
        }else if(root->rchild == NULL){ //右子树为空，左子树直接顶上去
           BiTree tempNode = root;//临时指针
           root = root->lchild;
           free(tempNode);
        }else{  //左右子树都不为空
            //一般的删除策略是左子树的最大数据 或 右子树的最小数据 代替要删除的节点(这里采用查找左子树最大数据来代替)
            BiTree tempNode = root->lchild;
            if(tempNode->rchild!=NULL){
                tempNode = tempNode->rchild;
            }
            root->key = tempNode->key;
            DeleteNode(root->lchild,tempNode->key);
        }
    }
}

void InOrder(BiTree T)
{
	if(T!=NULL)
	{
		InOrder(T->lchild);
		printf("%3d",T->key);
		InOrder(T->rchild);
	}
}
//《王道C督学营》课程
//二叉排序树的创建，中序遍历，查找，删除
int main()
{
	BiTree T=NULL;//树根
	BiTree parent;//存储父亲结点的地址值
	BiTree search;
	KeyType str[7]={54,20,66,40,28,79,58};//将要进入二叉排序树的元素值
	Creat_BST(T,str,7);
	InOrder(T);
	printf("\n");
	search=BST_Search(T,40,parent);
	if(search)
	{
		printf("找到对应结点，值=%d\n",search->key);
	}else{
		printf("未找到对应结点\n");//没找到search返回的是NULL
	}
	DeleteNode(T,54);//删除某个结点
	InOrder(T);
	printf("\n");
	system("pause");
}
```

## 查找

### KMP

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef char* SString;
//暴力比对
//S  abcabaaabaabcac
//T  abaabcac
//为什么从1位置开始比较，因为0号位置存储了字符串的长度
int Index(SString S,SString T)
{
	int i=1,j=1;
	while(i<=S[0]&&j<=T[0])
	{
		if(S[i]==T[j])
		{
			++i,++j;//继续比较后续字符
		}else{
			i=i-j+2;j=1;//指针后退重新开始匹配
		}
	}
	if(j>T[0]) return i-T[0];//匹配成功
	else return 0;
}
//i游标，遍历T，现在直播不懂那么别去调试get_next代码
void get_next(char T[],int next[])
{
	int i=1;
	next[1]=0;//恒为零
	int j=0;
	//abaabcac
	while(i<T[0])//T[0]中记录了字符串的长度
	{
		if(j==0||T[i]==T[j])//j==0，说明再次回到了开头
		{
			++i;++j;
			next[i]=j;//记录出现重复的位置
		}else{
			j=next[j];//不相同，找个位置重新比较
		}
	}
}
//S  abcabaaabaabcac
//T  abaabcac
int KMP(char S[],char T[],int next[],int pos)
{
	int i=pos;//开始查找的起始位置
	int j=1;
	while(i<=S[0]&&j<=T[0])
	{
		if(j==0||S[i]==T[j]){//相等各自加加，往后走
			++i;
			++j;
		}
		else//不等，就回退next[j]的位置
			j=next[j];
	}
	if(j>T[0])//说明比对成功
		return i-T[0];
	else
		return 0;
}
//《王道C督学营》课程
//简单模式匹配 与  KMP（KMP考的概率极低）
int main()
{
	//字符串进行初始化
	char S[256];
	char T[10];
	int next[10];
	int pos;
	S[0]=strlen("abcabaaabaabcac");//strlen里有多少个字符
	strcpy(S+1,"abcabaaabaabcac");
	T[0]=strlen("abaabcac");
	strcpy(T+1,"abaabcac");
	pos=Index(S,T);//暴力匹配
	if(pos)
	{
		printf("匹配成功，位置为%d\n",pos);
	}else{
		printf("未匹配\n");
	}
	get_next(T,next);//算出next数组
	pos=KMP(S,T,next,1);
	if(pos)
	{
		printf("匹配成功，位置为%d\n",pos);
	}else{
		printf("未匹配\n");
	}
	system("pause");
}

```

### 顺序与折半

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
typedef int ElemType;
typedef struct{
	ElemType *elem;//整型指针
	int TableLen;//存储动态数组里边元素的个数
}SSTable;

int Search_Seq(SSTable ST,ElemType key)
{
	ST.elem[0]=key;//让零号元素作为哨兵
	int i;
	for(i=ST.TableLen-1;ST.elem[i]!=key;--i);
	return i;
}
//init进行了随机数生成
void ST_Init(SSTable &ST,int len)
{
	ST.TableLen=len+1;//多申请了一个位置,为了存哨兵
	ST.elem=(ElemType *)malloc(sizeof(ElemType)*ST.TableLen);
	int i;
	srand(time(NULL));//随机数生成
	for(i=0;i<ST.TableLen;i++)//为啥这里零号位置也随机了数据，为折半查找服务
	{
		ST.elem[i]=rand()%100;
	}
}
void ST_print(SSTable ST)
{
	for(int i=0;i<ST.TableLen;i++)
	{
		printf("%3d",ST.elem[i]);
	}
	printf("\n");
}
//时间复杂度  logn
int Binary_Search(SSTable L,ElemType key)
{
	int low=0,high=L.TableLen-1,mid;
	while(low<=high)
	{
		mid=(low+high)/2;
		if(L.elem[mid]==key)
			return mid;//等于就找到了
		else if(L.elem[mid]>key)
			high=mid-1;
		else
			low=mid+1;
	}
	return -1;
}
int compare(const void *left,const void *right)//left，right是任意两个元素的地址值
{
	return *(ElemType*)left-*(ElemType*)right;
	//return *(ElemType*)right - *(ElemType*)left;//从大到小
}
//《王道C督学营》课程
//顺序查找 与  折半查找
int main()
{
	SSTable ST;
	ElemType key;
	int pos;//存储查询元素的位置
	ST_Init(ST,10);
	ST_print(ST);
	printf("请输入要搜索的key值:\n");
	scanf("%d",&key);
	pos=Search_Seq(ST,key);
	if(pos)
	{
		printf("查找成功 位置为 %d\n",pos);
	}else{
		printf("查找失败\n");
	}
	qsort(ST.elem,ST.TableLen,sizeof(ElemType),compare);//qsort实现的是快排
	ST_print(ST);
	printf("二分查找，请输入要搜索的key值:\n");
	scanf("%d",&key);
	//有序数组
	pos=Binary_Search(ST,key);//二分查找，也叫折半查找
	if(pos!=-1)
	{
		printf("查找成功 位置为 %d\n",pos);
	}else{
		printf("查找失败\n");
	}
	system("pause");
}

```

### 散列表

```c++
#define MaxKey 1000
#include <stdio.h>
//这就是哈希函数
int hash(const char* key)
{
	int h = 0, g;
	while (*key)
	{
		h = (h << 4) + *key++;
		g = h & 0xf0000000;
		if (g)
		{
			h ^= g >> 24;
		}
		h &= ~g;
	}
	return h % MaxKey;//算出下标要取余
}


int main()
{
	const char* pStr[5] = { "xiongda","lele","hanmeimei","wangdao","fenghua" };
	int i;
	const char* pHash_table[MaxKey] = {NULL};//哈希表，散列表
	for (i = 0; i < 5; i++)
	{
		printf("%s is key=%d\n", pStr[i], hash(pStr[i]));//算哈希值并打印
		pHash_table[hash(pStr[i])] = pStr[i];//存入哈希表
	}
	return 0;
}
```

## 排序![image-20220819160105279](G:\OneDrive - monster666\文档\数据结构.assets\image-20220819160105279.png)

![image-20220806104650088](G:\OneDrive - monster666\文档\数据结构.assets\image-20220806104650088.png)



### 插入

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
typedef int ElemType;
typedef struct{
	ElemType *elem;//整型指针
	int TableLen;
}SSTable;

void ST_Init(SSTable &ST,int len)
{
	ST.TableLen=len+1;//实际申请11个元素的空间
	ST.elem=(ElemType *)malloc(sizeof(ElemType)*ST.TableLen);
	int i;
	srand(time(NULL));
	for(i=0;i<ST.TableLen;i++)
	{
		ST.elem[i]=rand()%100;//随机了11个数，但是第一个元素是没有用到的
	}
}
void ST_print(SSTable ST)
{
	for(int i=0;i<ST.TableLen;i++)
	{
		printf("%3d",ST.elem[i]);
	}
	printf("\n");
}
//插入排序，从小到大排序，升序
void InsertSort(ElemType A[],int n)
{
	int i,j;
	//24 66 94  2 15 74 28 51 22 18  2
	for(i=2;i<=n;i++)//第零个元素是哨兵，从第二个元素开始拿，往前面插入
	{
		if(A[i]<A[i-1])
		{
			A[0]=A[i];//放到暂存位置，A[0]即是暂存，也是哨兵
			for(j=i-1;A[0]<A[j];--j)//移动元素，内层循环控制有序序列中的每一个元素和要插入的元素比较
				A[j+1]=A[j];
			A[j+1]=A[0];//把暂存元素插入到对应位置
		}
	}
}
//折半查找 插入排序，考的很少
void MidInsertSort(ElemType A[],int n)
{
	int i,j,low,high,mid;
	for(i=2;i<=n;i++)
	{
		A[0]=A[i];
		low=1;high=i-1;//low有序序列的开始，high有序序列的最后
		while(low<=high)//先通过二分查找找到待插入位置
		{
			mid=(low+high)/2;
			if(A[mid]>A[0])
				high=mid-1;
			else
				low=mid+1;
		}
		for(j=i-1;j>=high+1;--j)
			A[j+1]=A[j];
		A[high+1]=A[0];
	}
}
//希尔排序  
//多轮插入排序，考大题的概率约等于零，因为编写起来复杂，同时效率并不如快排，堆排
//小题主要考步长的变化是如何的
void ShellSort(ElemType A[],int n)
{
	int dk,i,j;
	// 73 29 74 51 29 90 37 48 72 54 83
	for(dk=n/2;dk>=1;dk=dk/2)//步长变化，步长变化
	{
		for(i=dk+1;i<=n;++i)//以dk为步长进行插入排序
		{
			if(A[i]<A[i-dk])
			{
				A[0]=A[i];
				for(j=i-dk;j>0&&A[0]<A[j];j=j-dk)
					A[j+dk]=A[j];
				A[j+dk]=A[0];
			}
		}
	}
}

//《王道C督学营》
int main()
{
	SSTable ST;
	ElemType A[10] = { 64, 94, 95, 79, 69, 84, 18, 22, 12 ,78 };
	ST_Init(ST,10);//实际申请了11个元素空间
	memcpy(ST.elem+1, A, sizeof(A));
	ST_print(ST);
	//InsertSort(ST.elem,10);
	//MidInsertSort(ST.elem,10);
	ShellSort(ST.elem,10);
	ST_print(ST);
	system("pause");
}
```

### 交换

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
typedef int ElemType;
typedef struct{
	ElemType *elem;//存储元素的起始地址
	int TableLen;//元素个数
}SSTable;

void ST_Init(SSTable &ST,int len)
{
	ST.TableLen=len;
	ST.elem=(ElemType *)malloc(sizeof(ElemType)*ST.TableLen);
	int i;
	srand(time(NULL));//随机数生成，每一次执行代码就会得到随机的10个元素
	for(i=0;i<ST.TableLen;i++)
	{
		ST.elem[i]=rand()%100;//生成的是0-99之间
	}
}
void ST_print(SSTable ST)
{
	for(int i=0;i<ST.TableLen;i++)
	{
		printf("%3d",ST.elem[i]);
	}
	printf("\n");
}
void swap(ElemType &a,ElemType &b)
{
	ElemType tmp;
	tmp=a;
	a=b;
	b=tmp;
}
// 64 94 95 79 69 84 18 22 12 78
// 12 64 94 95 79 69 84 18 22 78
void BubbleSort(ElemType A[],int n)
{
	int i,j;
	bool flag;
	for(i=0;i<n-1;i++)//i最多访问到8
	{
		for(j=n-1;j>i;j--)//把最小值就放在最前面
		{
			flag=false;
			if(A[j-1]>A[j])
			{
				swap(A[j-1],A[j]);
				flag=true;
			}
			if(false==flag)
				return;
		}
	}
}

void BubbleSort1(ElemType A[], int n)
{
	int i, j,flag;
	for (i=0;i<n-1;i++)//i是控制有多少个有序了
	{
		for (j = n-1; j>i;j--)//内层控制比较，交换
		{
			flag = 0;
			if (A[j - 1] > A[j])
			{
				swap(A[j - 1], A[j]);
				flag = 1;
			}
			if (0 == flag)
			{
				break;
			}
		}
	}
}
// 64 94 95 79 69 84 18 22 12 78
//比64小的放在左边，比64大的放在右边
// 挖坑法，王道书上使用的方法，最左边作为分割值
int Partition(ElemType A[],int low,int high)
{
	ElemType pivot=A[low];//把最左边的值暂存起来
	while(low<high)
	{
		while(low<high&&A[high]>=pivot)//让high从最右边找，找到比分割值小，循环结束
			--high;
		A[low]=A[high];
		while(low<high&&A[low]<=pivot)//让low从最左边开始找，找到比分割值大，就结束
			++low;
		A[high]=A[low];
	}
	A[low]=pivot;
	return low;
}
//交换法
int Partition1(int* arr, int left, int right)
{
	int k, i;//k记录要放入比分割值小的数据的位置
	for (i = left, k = left; i < right; i++)
	{
		if (arr[i] < arr[right])
		{
			swap(arr[k], arr[i]);
			k++;
		}
	}
	swap(arr[k], arr[right]);
	return k;
}
//交换法
int Partition2(int* arr, int left, int right)
{
	int k, i;
	for (k = i = left;i<right;i++)
	{
		if (arr[i] < arr[right])
		{
			swap(arr[i], arr[k]);
			k++;
		}
	}
	swap(arr[k], arr[right]);
	return k;
}
//递归实现
void QuickSort(ElemType A[],int low,int high)
{
	if(low<high)
	{
		int pivotpos=Partition(A,low,high);//分割点左边的元素都比分割点要小，右边的比分割点大
		QuickSort(A,low,pivotpos-1);
		QuickSort(A,pivotpos+1,high);
	}
}
//《王道C督学营》课程
//冒泡排序与快速排序
int main()
{
	SSTable ST;
	ElemType A[10]={ 64, 94, 95, 79, 69, 84, 18, 22, 12 ,78};
	ST_Init(ST,10);//初始化
	memcpy(ST.elem,A,sizeof(A));//内存copy接口，当你copy整型数组，或者浮点型时，要用memcpy
	ST_print(ST);
	//BubbleSort1(ST.elem,10);//冒泡排序
	QuickSort(ST.elem,0,9);
	ST_print(ST);
	system("pause");
}
```

### 选择

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
typedef int ElemType;
typedef struct{
	ElemType *elem;
	int TableLen;
}SSTable;

void ST_Init(SSTable &ST,int len)//申请空间，并进行随机数生成
{
	ST.TableLen=len;
	ST.elem=(ElemType *)malloc(sizeof(ElemType)*ST.TableLen);
	int i;
	srand(time(NULL));
	for(i=0;i<ST.TableLen;i++)
	{
		ST.elem[i]=rand()%100;
	}
}
void ST_print(SSTable ST)
{
	for(int i=0;i<ST.TableLen;i++)
	{
		printf("%3d",ST.elem[i]);
	}
	printf("\n");
}
void swap(ElemType &a,ElemType &b)
{
	ElemType tmp;
	tmp=a;
	a=b;
	b=tmp;
}
void SelectSort(ElemType A[],int n)
{
	int i,j,min;//min记录最小的元素的下标
	for(i=0;i<n-1;i++)//最多可以为8
	{
		min=i;
		for(j=i+1;j<n;j++)//j最多可以为9
		{
			if(A[j]<A[min])
				min=j;
		}
		if(min!=i)
		{
			swap(A[i],A[min]);
		}
	}
}
//调整某个父亲节点
void AdjustDown(ElemType A[],int k,int len)
{
	int i;
	A[0]=A[k];
	for(i=2*k;i<=len;i*=2)
	{
		if(i<len&&A[i]<A[i+1])//左子节点与右子节点比较大小
			i++;
		if(A[0]>=A[i])
			break;
		else{
			A[k]=A[i];
			k=i;
		}
	}
	A[k]=A[0];
}
//用数组去表示树   层次建树
void BuildMaxHeap(ElemType A[],int len)
{
	for(int i=len/2;i>0;i--)
	{
		AdjustDown(A,i,len);
	}
}
void HeapSort(ElemType A[],int len)
{
	int i;
	BuildMaxHeap(A,len);//建立大顶堆
	for(i=len;i>1;i--)
	{
		swap(A[i],A[1]);
		AdjustDown(A,1,i-1);
	}
}
//调整子树
void AdjustDown1(ElemType A[], int k, int len)
{
	int dad = k;
	int son = 2 * dad + 1; //左孩子下标
	while (son<=len)
	{
		if (son + 1 <= len && A[son] < A[son + 1])//看下有没有右孩子，比较左右孩子选大的
		{
			son++;
		}
		if (A[son] > A[dad])//比较孩子和父亲
		{
			swap(A[son], A[dad]);
			dad = son;
			son = 2 * dad + 1;
		}
		else {
			break;
		}
	}
}
void HeapSort1(ElemType A[], int len)
{
	int i;
	//建立大顶堆
	for (i = len / 2; i >= 0; i--)
	{
		AdjustDown1(A, i, len);
	}
	swap(A[0], A[len]);//交换顶部和数组最后一个元素
	for (i = len - 1; i > 0; i--)
	{
		AdjustDown1(A, 0, i);//剩下元素调整为大根堆
		swap(A[0], A[i]);
	}
}

//《王道C督学营》课程
//选择排序与堆排序
int main()
{
	SSTable ST;
	ElemType A[10]={ 64, 94, 95, 79, 69, 84, 18, 22, 12 ,99};
	ST_Init(ST,10);//初始化
	memcpy(ST.elem,A,sizeof(A));
	ST_print(ST);
	//SelectSort(ST.elem,10);
	HeapSort(ST.elem, 9);//王道书零号元素不参与排序
	//HeapSort1(ST.elem,9);//所有元素参与排序
	ST_print(ST);
	system("pause");
}
```

### 归并

```c++
#include <stdio.h>
#include <stdlib.h>

#define N 7
typedef int ElemType;
//49,38,65,97,76,13,27
void Merge(ElemType A[],int low,int mid,int high)
{
	ElemType B[N];//为了降低操作次数
	int i,j,k;
	for(k=low;k<=high;k++)//复制元素到B中
		B[k]=A[k];
	for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++)//合并两个有序数组
	{
		if(B[i]<=B[j])
			A[k]=B[i++];
		else
			A[k]=B[j++];
	}
	while(i<=mid)//如果有剩余元素，接着放入即可
		A[k++]=B[i++];
	while(j<=high)
		A[k++]=B[j++];
}
//归并排序不限制是两两归并，还是多个归并
// 1 3 5 7 9
// 2 4
// 1 2 3 4 5 7 9  主要的代码逻辑
void MergeSort(ElemType A[],int low,int high)//递归分割
{
	if(low<high)
	{
		int mid=(low+high)/2;
		MergeSort(A,low,mid);
		MergeSort(A,mid+1,high);
		Merge(A,low,mid,high);
	}
}
void print(int* a)
{
	for(int i=0;i<N;i++)
	{
		printf("%3d",a[i]);
	}
	printf("\n");
}
//《王道C督学营》课程
// 归并排序
int main()
{
	int A[7]={49,38,65,97,76,13,27};//数组，7个元素
	MergeSort(A,0,6);
	print(A);
}

```

## 图的遍历

```c++
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>

#define MAX 100
#define isLetter(a)  ((((a)>='a')&&((a)<='z')) || (((a)>='A')&&((a)<='Z')))
#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))

// 邻接表中表对应的链表的顶点
typedef struct _ENode
{
    int ivex;                   // 该边所指向的顶点的位置,是数组的下标
    struct _ENode *next_edge;   // 指向下一条弧的指针
}ENode, *PENode;

// 邻接表中表的顶点
typedef struct _VNode
{
    char data;              // 顶点信息
    ENode *first_edge;      // 指向第一条依附该顶点的弧
}VNode;

// 邻接表
typedef struct _LGraph
{
    int vexnum;             // 图的顶点的数目
    int edgnum;             // 图的边的数目
    VNode vexs[MAX];
}LGraph;

/*
 * 返回ch在matrix矩阵中的位置
 */
static int get_position(LGraph g, char ch)
{
    int i;
    for(i=0; i<g.vexnum; i++)//去顶点结构体数组中遍历每个顶点
        if(g.vexs[i].data==ch)
            return i;//返回的是对应顶点的下标
    return -1;
}

/*
 * 读取一个输入字符
 */
static char read_char()
{
    char ch;

    do {
        ch = getchar();
    } while(!isLetter(ch));

    return ch;
}

/*
 * 将node链接到list的末尾
 */
static void link_last(ENode *list, ENode *node)
{
    ENode *p = list;

    while(p->next_edge)
        p = p->next_edge;
    p->next_edge = node;
}

/*
 * 创建邻接表对应的图(自己输入)
 */
LGraph* create_lgraph()
{
    char c1, c2;
    int v, e;
    int i, p1, p2;
    ENode *node1, *node2;
    LGraph* pG;

    // 输入"顶点数"和"边数"
    printf("input vertex number: ");
    scanf("%d", &v);
    printf("input edge number: ");
    scanf("%d", &e);
    if ( v < 1 || e < 1 || (e > (v * (v-1))))
    {
        printf("input error: invalid parameters!\n");
        return NULL;
    }
 
    if ((pG=(LGraph*)malloc(sizeof(LGraph))) == NULL )
        return NULL;
    memset(pG, 0, sizeof(LGraph));

    // 初始化"顶点数"和"边数"
    pG->vexnum = v;
    pG->edgnum = e;
    // 初始化"邻接表"的顶点
    for(i=0; i<pG->vexnum; i++)
    {
        printf("vertex(%d): ", i);
        pG->vexs[i].data = read_char();
        pG->vexs[i].first_edge = NULL;
    }

    // 初始化"邻接表"的边
    for(i=0; i<pG->edgnum; i++)
    {
        // 读取边的起始顶点和结束顶点
        printf("edge(%d): ", i);
        c1 = read_char();
        c2 = read_char();

        p1 = get_position(*pG, c1);
        p2 = get_position(*pG, c2);

        // 初始化node1
        node1 = (ENode*)calloc(1,sizeof(ENode));
        node1->ivex = p2;
        // 将node1链接到"p1所在链表的末尾"
        if(pG->vexs[p1].first_edge == NULL)
          pG->vexs[p1].first_edge = node1;
        else
            link_last(pG->vexs[p1].first_edge, node1);
        // 初始化node2
        node2 = (ENode*)calloc(1,sizeof(ENode));
        node2->ivex = p1;
        // 将node2链接到"p2所在链表的末尾"
        if(pG->vexs[p2].first_edge == NULL)
          pG->vexs[p2].first_edge = node2;
        else
            link_last(pG->vexs[p2].first_edge, node2);
    }

    return pG;
}

/*
 * 创建邻接表对应的图(用已提供的数据)，无向图
 */
LGraph* create_example_lgraph()
{
    char c1, c2;
    char vexs[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
    char edges[][2] = {
        {'A', 'C'}, 
        {'A', 'D'}, 
        {'A', 'F'}, 
        {'B', 'C'}, 
        {'C', 'D'}, 
        {'E', 'G'}, 
        {'F', 'G'}}; 
    int vlen = LENGTH(vexs);
    int elen = LENGTH(edges);
    //上面类似一个邻接矩阵存储
    int i, p1, p2;
    ENode *node1, *node2;
    LGraph* pG;//pG表示图


    if ((pG=(LGraph*)malloc(sizeof(LGraph))) == NULL )
        return NULL;
    memset(pG, 0, sizeof(LGraph));//就是把申请的空间内初始化为零

    // 初始化"顶点数"和"边数"
    pG->vexnum = vlen;
    pG->edgnum = elen;
    // 初始化"邻接表"的顶点
    for(i=0; i<pG->vexnum; i++)
    {
        pG->vexs[i].data = vexs[i];
        pG->vexs[i].first_edge = NULL;
    }

    // 初始化"邻接表"的边
    for(i=0; i<pG->edgnum; i++)
    {
        // 读取边的起始顶点和结束顶点
        c1 = edges[i][0];
        c2 = edges[i][1];

        p1 = get_position(*pG, c1);//p1对应起始顶点下标位置
        p2 = get_position(*pG, c2);//p1对应结束顶点下标位置

        // 初始化node1
        node1 = (ENode*)calloc(1,sizeof(ENode));
        node1->ivex = p2;
        // 将node1链接到"p1所在链表的末尾"
        if(pG->vexs[p1].first_edge == NULL)
            pG->vexs[p1].first_edge = node1;
        else
            link_last(pG->vexs[p1].first_edge, node1);
        // 初始化node2
        node2 = (ENode*)calloc(1,sizeof(ENode));
        node2->ivex = p1;
        // 将node2链接到"p2所在链表的末尾"
        if(pG->vexs[p2].first_edge == NULL)
            pG->vexs[p2].first_edge = node2;
        else
            link_last(pG->vexs[p2].first_edge, node2);
    }

    return pG;
}

/*
 * 深度优先搜索遍历图的递归实现
 */
static void DFS(LGraph G, int i, int *visited)
{
    ENode *node;

    visited[i] = 1;//要访问当前结点了，所以打印
    printf("%c ", G.vexs[i].data);
    node = G.vexs[i].first_edge;//拿当前顶点的后面一个顶点
    while (node != NULL)
    {
        if (!visited[node->ivex])//只要对应顶点没有访问过，深入到下一个顶点访问
            DFS(G, node->ivex, visited);
        node = node->next_edge;//某个顶点的下一条边，例如B结点的下一条边
    }
}

/*
 * 深度优先搜索遍历图
 */
void DFSTraverse(LGraph G)
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i < G.vexnum; i++)
        visited[i] = 0;

    printf("DFS: ");
	//从A开始深度优先遍历
    for (i = 0; i < G.vexnum; i++)
    {
        if (!visited[i])
            DFS(G, i, visited);
    }
    printf("\n");
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void BFS(LGraph G)
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;
    ENode *node;

	//每个顶点未被访问
    for (i = 0; i < G.vexnum; i++)
        visited[i] = 0;
	//从零号顶点开始遍历
    printf("BFS: ");
    for (i = 0; i < G.vexnum; i++)//对每个连同分量均调用一次BFS
    {
        if (!visited[i])//如果没访问过，就打印，同时入队,最初是A
        {
            visited[i] = 1;//标记已经访问过
            printf("%c ", G.vexs[i].data);
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) //第一个进来的是A，遍历A的每一条边
        {
            j = queue[head++];  // 出队列
            node = G.vexs[j].first_edge;
            while (node != NULL)
            {
                k = node->ivex;
                if (!visited[k])
                {
                    visited[k] = 1;
                    printf("%c ", G.vexs[k].data);
                    queue[rear++] = k;//类似于树的层次遍历，遍历到的同时入队
                }
                node = node->next_edge;
            }
        }
    }
    printf("\n");
}

/*
 * 打印邻接表图
 */
void print_lgraph(LGraph G)
{
    int i;
    ENode *node;

    printf("List Graph:\n");
    for (i = 0; i < G.vexnum; i++)//遍历所有的顶点
    {
        printf("%d(%c): ", i, G.vexs[i].data);
        node = G.vexs[i].first_edge;
        while (node != NULL)//把每个顶点周围的结点都输出一下
        {
            printf("%d(%c) ", node->ivex, G.vexs[node->ivex].data);
            node = node->next_edge;
        }
        printf("\n");
    }
}
/*
 * 创建邻接表对应的图(有向图)
 */
LGraph* create_example_lgraph_directed()
{
    char c1, c2;
    char vexs[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
    char edges[][2] = {
        {'A', 'B'}, 
        {'B', 'C'}, 
        {'B', 'E'}, 
        {'B', 'F'}, 
        {'C', 'E'}, 
        {'D', 'C'}, 
        {'E', 'B'}, 
        {'E', 'D'}, 
        {'F', 'G'}}; 
    int vlen = LENGTH(vexs);
    int elen = LENGTH(edges);
    int i, p1, p2;
    ENode *node1;
    LGraph* pG;


    if ((pG=(LGraph*)malloc(sizeof(LGraph))) == NULL )
        return NULL;
    memset(pG, 0, sizeof(LGraph));

    // 初始化"顶点数"和"边数"
    pG->vexnum = vlen;
    pG->edgnum = elen;
    // 初始化"邻接表"的顶点
    for(i=0; i<pG->vexnum; i++)
    {
        pG->vexs[i].data = vexs[i];
        pG->vexs[i].first_edge = NULL;
    }

    // 初始化"邻接表"的边
    for(i=0; i<pG->edgnum; i++)
    {
        // 读取边的起始顶点和结束顶点
        c1 = edges[i][0];
        c2 = edges[i][1];

        p1 = get_position(*pG, c1);
        p2 = get_position(*pG, c2);
        // 初始化node1
        node1 = (ENode*)calloc(1,sizeof(ENode));
        node1->ivex = p2;
        // 将node1链接到"p1所在链表的末尾"
        if(pG->vexs[p1].first_edge == NULL)
            pG->vexs[p1].first_edge = node1;
        else
            link_last(pG->vexs[p1].first_edge, node1);
    }

    return pG;
}
//《王道C督学营》课程
//图的创建，打印，广度优先遍历，深度优先遍历
//讲 有向图
void main()
{
    LGraph* pG;

    // 无向图自定义"图"(自己输入数据，输入的方法可以参考create_example_lgraph初始化好的数据)
    //pG = create_lgraph();
    //// 无向图的创建，采用已有的"图"
    //pG = create_example_lgraph();
	//有向图的创建
	pG = create_example_lgraph_directed();
    // 打印图
    print_lgraph(*pG);
    DFSTraverse(*pG);//深度优先遍历
	BFS(*pG);//广度优先遍历
	system("pause");
}
```

### Dijkstra 无向图

```c++
#define _CRT_SECURE_NO_WARNINGS
#include"iostream"
#include"cstring"
#include"cstdio"

using namespace std;
#define INF 0x7f7f7f7f

const int N = 5; //点的个数上限

int maze[N][N];
int dis[N];
bool vis[N];

//点的个数和边的条数
int n, m;

void init()
{
    memset(maze, INF, sizeof(maze));
    memset(dis, INF, sizeof(dis));
    memset(vis, false, sizeof(vis));
    for (int i = 0; i < N; i++)
    {
        maze[i][i] = 0;
    }
}

void dijkstra(int st)
{
    dis[st] = 0;
    for (int i = 0; i < n; i++)
    {
        //找到和起点距离最短的点
        int minx = INF;
        int minmark;
        for (int j = 0; j < n; j++)
        {
            if (vis[j] == false && dis[j] <= minx)
            {
                minx = dis[j];
                minmark = j;
            }
        }
        //并标记
        vis[minmark] = true;
        //更新所有和它连接的点的距离
        for (int j = 0; j < n; j++)
        {
            if (vis[j] == false && dis[j] > dis[minmark] + maze[minmark][j])
                dis[j] = dis[minmark] + maze[minmark][j];
        }
    }
}


int main()
{
    while (scanf("%d %d", &n, &m) != EOF)
    {
        if (n == 0 && m == 0) break;
        //每组数据都要初始化
        init();
        for (int i = 1; i <= m; i++)
        {
            int x, y, len;
            scanf("%d %d %d", &x, &y, &len);
            if (x != y && maze[x][y] > len)
            {
                maze[y][x] = len;
                maze[x][y] = len;
            }
        }
        //以0为起点跑一次dij
        dijkstra(0);

    }
}

```

## STL

### stack

```c++
#include <iostream>
#include <stack>
#include <list>
using namespace std;
int main()
{
    ////构建 stack 容器适配器
    //list<int> values{ 1, 2, 3 };  //这个是C++ 11才支持的
    //stack<int, list<int>> my_stack(values);
	stack<int> my_stack;
	my_stack.push(1);
	my_stack.push(2);
	my_stack.push(3);
    //查看 my_stack 存储元素的个数
    cout << "size of my_stack: " << my_stack.size() << endl;
    //将 my_stack 中存储的元素依次弹栈，直到其为空
    while (!my_stack.empty())
    {  
        cout << my_stack.top() << endl;
        //将栈顶元素弹栈
        my_stack.pop();
    }
	cout<<"100  " <<100<<endl;
	system("pause");
    return 0;
}
```

### vector动态数组 向量

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
 
void vec_insert()
{
	//创建一个vector,置入字母表的前十个字符
	vector<char> alphaVector;
	for( int i=0; i < 10; i++ )
	  alphaVector.push_back( i + 65 );

	//插入四个C到vector中
	vector<char>::iterator theIterator = alphaVector.begin();
	alphaVector.insert( theIterator+4, 4, 'C' );

	//显示vector的内容
	for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ )
	  cout << *theIterator;

	cout<<endl;
	std::sort (alphaVector.begin(), alphaVector.begin()+6);

	//显示vector的内容
	for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ )
	  cout << *theIterator;
	cout<<endl;
}


void vec_del()
{
	// 创建一个vector,置入字母表的前十个字符
	vector<char> alphaVector;
	for( int i=0; i < 10; i++ )
		alphaVector.push_back( i + 65 );
	int size = alphaVector.size();

	vector<char>::iterator startIterator;
	vector<char>::iterator tempIterator;

	for( int i=0; i < size; i++ )
	{
		startIterator = alphaVector.begin();
		alphaVector.erase( startIterator );

		// Display the vector
		for( tempIterator = alphaVector.begin(); tempIterator != alphaVector.end(); tempIterator++ )
		{
			cout << *tempIterator;
		}
		cout << endl;
	} 
}

int main()
{
   // 创建一个向量存储 int
   vector<int> vec; 
   int i;
 
   // 显示 vec 的原始大小
   cout << "vector size = " << vec.size() << endl;
   // 显示 vec 原始的capacity大小
   cout << "vector capacity = " << vec.capacity() << endl;
   // 推入 5 个值到向量中
   for(i = 0; i < 5; i++){
      vec.push_back(i);
   }
 
   // 显示 vec 扩展后的大小
   cout << "extended vector size = " << vec.size() << endl;
   // 显示 vec 扩展后的capacity大小
   cout << "extended vector capacity = " << vec.capacity() << endl;
   
   // 访问向量中的 5 个值
   for(i = 0; i < 5; i++){
      cout << "value of vec [" << i << "] = " << vec[i] << endl;
   }

   // 使用迭代器 iterator 访问值
   vector<int>::iterator v = vec.begin();
   while( v != vec.end()) {
      cout << "value of v = " << *v << endl;
      v++;
   }
   
   vec.pop_back();
   cout << "vector pop 后的 size = " << vec.size() << endl;

   vec_insert();

   vec_del();
   system("pause");
   return 0;
}

//array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，
//在使用该容器的过程无法借由增加或移除元素而改变其大小，它只允许访问或者替换存储的元素。
```

### list链表

```c++
#include <iostream>
#include <list>
using namespace std;
int main()
{
    //创建空的 list 容器
    std::list<double> values;
    //向容器中添加元素
    values.push_back(3.1);
    values.push_back(2.2);
    values.push_back(2.9);
    cout << "values size：" << values.size() << endl;
    //对容器中的元素进行排序
    values.sort();
    //使用迭代器输出list容器中的元素
    for (std::list<double>::iterator it = values.begin(); it != values.end(); it++) {
        std::cout << *it << " ";
    }
	cout<<endl;

//	假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1--、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：
//p1[i]：不能通过下标访问 list 容器中指定位置处的元素。
//p1-=i、 p1+=i、 p1+i 、p1-i：双向迭代器 p1 不支持使用 -=、+=、+、- 运算符。
//p1<p2、 p1>p2、 p1<=p2、 p1>=p2：双向迭代器 p1、p2 不支持使用 <、 >、 <=、 >= 比较运算符。

	std::list<double>::iterator begin = values.begin();
	begin++;
	values.insert(begin, 5.6);

	for (std::list<double>::iterator it = values.begin(); it != values.end(); ++it) {
        std::cout << *it << " ";
    }
	cout<<endl;
	std::list<double>::iterator end = values.end();
	end--;
	values.erase(end);

	for (std::list<double>::iterator it = values.begin(); it != values.end(); ++it) {
        std::cout << *it << " ";
    }
	system("pause");
    return 0;
}

//deque 是 double-ended queue 的缩写，又称双端队列容器。
//
//前面章节中，我们已经系统学习了 vector 容器，值得一提的是，deque 容器和 vecotr 容器有很多相似之处，比如：
//deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。
//deque 容器也可以根据需要修改自身的容量和大小。
//
//和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶O(1)。
//并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。
//因为考研初试，机试完全用不到deque，因此这里不再介绍
```

### string

```c++
#include <iostream>
#include <string>
using namespace std;


void str_substr()
{
	string s="abcdefg";

    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串
    string s2=s.substr(1,5);//bcdef

	cout<<s2<<endl;
    //s.substr(pos)//得到一个pos到结尾的串
    string s3=s.substr(4);//efg
	cout<<s3<<endl;
}

void str_find()
{
	string s1("Source Code");
    int n;
    if ((n = s1.find('u')) != string::npos) //查找 u 出现的位置
        cout << "1) " << n << "," << s1.substr(n) << endl;
    //输出 l)2,urce Code
    if ((n = s1.find("Source", 3)) == string::npos)
        //从下标3开始查找"Source"，找不到
        cout << "2) " << "Not Found" << endl;  //输出 2) Not Found
    if ((n = s1.find("Co")) != string::npos)
        //查找子串"Co"。能找到，返回"Co"的位置
        cout << "3) " << n << ", " << s1.substr(n) << endl;
    //输出 3) 7, Code
    if ((n = s1.find_first_of("ceo")) != string::npos)
        //查找第一次出现或 'c'、'e'或'o'的位置
        cout << "4) " << n << ", " << s1.substr(n) << endl;
    //输出 4) l, ource Code
    if ((n = s1.find_last_of('e')) != string::npos)
        //查找最后一个 'e' 的位置
        cout << "5) " << n << ", " << s1.substr(n) << endl;  //输出 5) 10, e
    if ((n = s1.find_first_not_of("eou", 1)) != string::npos)
        //从下标1开始查找第一次出现非 'e'、'o' 或 'u' 字符的位置
        cout << "6) " << n << ", " << s1.substr(n) << endl;
    //输出 6) 3, rce Code
}

void str_replace()
{
	string s1("Real Steel");
	s1.replace(1, 5, "123456", 2, 4);  //用 "123456" 的子串(2,4) 替换 s1 的子串(1,3)
	cout << s1 << endl;  //输出 R3456 Steel
	string s2("Harry Potter");
	s2.replace(2, 3, 5, '0');  //用 5 个 '0' 替换子串(2,3)
	cout << s2 << endl;  //输出 HaOOOOO Potter
	int n = s2.find("00000");  //查找子串 "00000" 的位置，n=2
	s2.replace(n, 5, "XXX");  //将子串(n,5)替换为"XXX"
	cout << s2 << endl;  //输出 HaXXX Potter
}

void str_erase()
{
	string s1("Real Steel");
	s1.erase(1, 3);  //删除子串(1, 3)，此后 s1 = "R Steel"
	cout << s1 << endl;
	s1.erase(5);  //删除下标5及其后面的所有字符，此后 s1 = "R Ste"
	cout << s1 << endl;
}

void str_insert()
{
	string s1("Limitless"), s2("00");
	s1.insert(2, "123");  //在下标 2 处插入字符串"123"，s1 = "Li123mitless"
	cout << s1 << endl;
	s1.insert(3, s2);  //在下标 2 处插入 s2 , s1 = "Li10023mitless"
	cout << s1 << endl;
	s1.insert(3, 5, 'X');  //在下标 3 处插入 5 个 'X'，s1 = "Li1XXXXX0023mitless"
	cout << s1 << endl;
}

//主函数里都是初始化
int main()
{
	string s;//默认初始化，一个空字符串
    string s1("ssss");//s1是字面值“ssss”的副本
    string s2(s1);//s2是s1的副本
	s1[0]='b';
	cout<<s1<<endl;
	cout<<s2<<endl;
    string s3=s2;//s3是s2的副本
	s2[0]='c';
	cout<<s2<<endl;
	cout<<s3<<endl;
    string s4(10,'c');//把s4初始化
    string s5="hiya";//拷贝初始化
    string s6=string(10,'c');//拷贝初始化，生成一个初始化好的对象，拷贝给s6

    //string s(cp,n)
    char cs[]="12345";
    string s7(cs,3);//复制字符串cs的前3个字符到s当中

    //string s(s2,pos2)
    string s8="asac";
    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size

    //string s(s2,pos2,len2)
    string s10="qweqweqweq";
    string s11(s10,3,4);//s11是s10从下标3开始4个字符的拷贝，超过s10.size出现未定义
	cout<<s11<<endl;
	cout<<"------------------------------------"<<endl;
	str_substr();
	cout<<"------------------------------------"<<endl;
	str_find();
	cout<<"------------------------------------"<<endl;
	str_replace();
	cout<<"------------------------------------"<<endl;
	str_erase();
	cout<<"------------------------------------"<<endl;
	str_insert();
	system("pause");
    return 0;
}
```

### map

```c++
#include <map>  
  
#include <string>  
  
#include <iostream>  
  
using namespace std;  
  
int main()  
  
{  
  
       map<int, string> mapStudent;  
  
       mapStudent.insert(pair<int, string>(1, "student_one"));  
  
       mapStudent.insert(pair<int, string>(2, "student_two"));  
  
       mapStudent.insert(pair<int, string>(3, "student_three"));  
	   //相同key值不能插入
	   mapStudent.insert(pair<int, string>(1, "student_four")); 

	   cout<< mapStudent.size()<<endl;

	   map<int, string>::iterator iter;

	   for (iter=mapStudent.begin(); iter!=mapStudent.end(); iter++)
	   {
		   cout<< iter->first<< "  " << iter->second<<endl;
	   }
  
        //如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  
  
       //如果要删除1,用迭代器删除  
  
  
       iter = mapStudent.find(1);  
	   cout<<iter->second<<endl;
       mapStudent.erase(iter);  
  
       //如果要删除1，用关键字删除  
  
       int n = mapStudent.erase(1);//如果删除了会返回1，否则返回0  
  
       //用迭代器，成片的删除  
  
       //一下代码把整个map清空  
  
       mapStudent.erase( mapStudent.begin(), mapStudent.end() );  
  
       //成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  
  
       //自个加上遍历代码，打印输出吧  
	   system("pause");
}  
```

### set

```c++
#include <iostream>
#include <set>

using namespace std;

int main()
{
    set<int> s;
    s.insert(1);
    s.insert(2);
    s.insert(3);
    s.insert(1);
    cout<<"set 的 size 值为 ："<<s.size()<<endl;
    cout<<"set 的 maxsize的值为 ："<<s.max_size()<<endl;
    cout<<"set 中的第一个元素是 ："<<*s.begin()<<endl;
    //cout<<"set 中的最后一个元素是:"<<*s.end()<<endl;//这个在C++11是可以的
    s.clear();
    if(s.empty())
    {
        cout<<"set 为空 ！！！"<<endl;
    }
    cout<<"set 的 size 值为 ："<<s.size()<<endl;
    cout<<"set 的 maxsize的值为 ："<<s.max_size()<<endl;
	system("pause");
    return 0;
}
```



### 



### 









 
